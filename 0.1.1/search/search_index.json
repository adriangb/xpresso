{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction xpresso is an ASGI web framework built on top of Starlette , Pydantic and di , with heavy inspiration from FastAPI . Some of the standout features are: ASGI support for high performance (within the context of Python web frameworks) OpenAPI documentation generation Automatic parsing and validation of request bodies and parameters, with hooks for custom extractors Full support for OpenAPI parameter serialization Highly typed and tested codebase with great IDE support A powerful dependency injection system, backed by di Requirements Python 3.7+ Installation pip install xpresso You'll also want to install an ASGI server, such as Uvicorn . pip install uvicorn Example Create a file named example.py : from typing import List , Optional from pydantic import BaseModel from xpresso import App , PathItem , FromPath , FromQuery class UserModel ( BaseModel ): user_id : str age : Optional [ int ] = None async def get_users ( ids : FromPath [ List [ int ]], include_age : FromQuery [ bool ], ) -> List [ UserModel ]: if include_age : return [ UserModel ( user_id = user_id , age = 123 ) for user_id in ids ] return [ UserModel ( user_id = user_id ) for user_id in ids ] app = App ( routes = [ PathItem ( path = \"/users/ {ids} \" , get = get_users ) ] ) Run the application: uvicorn example:app For more examples, tutorials and reference materials, see our documentation .","title":"Intro"},{"location":"#introduction","text":"xpresso is an ASGI web framework built on top of Starlette , Pydantic and di , with heavy inspiration from FastAPI . Some of the standout features are: ASGI support for high performance (within the context of Python web frameworks) OpenAPI documentation generation Automatic parsing and validation of request bodies and parameters, with hooks for custom extractors Full support for OpenAPI parameter serialization Highly typed and tested codebase with great IDE support A powerful dependency injection system, backed by di","title":"Introduction"},{"location":"#requirements","text":"Python 3.7+","title":"Requirements"},{"location":"#installation","text":"pip install xpresso You'll also want to install an ASGI server, such as Uvicorn . pip install uvicorn","title":"Installation"},{"location":"#example","text":"Create a file named example.py : from typing import List , Optional from pydantic import BaseModel from xpresso import App , PathItem , FromPath , FromQuery class UserModel ( BaseModel ): user_id : str age : Optional [ int ] = None async def get_users ( ids : FromPath [ List [ int ]], include_age : FromQuery [ bool ], ) -> List [ UserModel ]: if include_age : return [ UserModel ( user_id = user_id , age = 123 ) for user_id in ids ] return [ UserModel ( user_id = user_id ) for user_id in ids ] app = App ( routes = [ PathItem ( path = \"/users/ {ids} \" , get = get_users ) ] ) Run the application: uvicorn example:app For more examples, tutorials and reference materials, see our documentation .","title":"Example"},{"location":"types/","text":"Typing in Python This documentation assumes that you are familiar with type annotations in Python. If you are not, that is okay! There are a lot of excellent guides out there to get you started: RealPython's Python Type Checking guide FastAPI's introduction to python types Runtime types (reflection) Most languages loose a lot of their type information at runtime. This can range between complete loss of type information (like TypeScript) or only weak support for runtime reflection (Golang). Python stands out for it's strong support for typing information at runtime (often called reflection ). Because of Python's dynamic runtime behavior, it is possible to read types and modify the runtime behavior of the program. Annotated and parameter metadata Python 3.9 (via PEP 593 ) introduced the Annotated typing construct. Since it's release in Python 3.9, this construct has been backported to older Python versions via the typing_extensions package. So it is available all the way back to Python 3.7. Xpresso uses Annotated extensively since it provides a composable, cohesive and widely supported pattern for attaching metadata for function parameters and class field declarations that is available at runtime. If you've used FastAPI, you may be used to declaring things like param: str = Path(gt=0) . When FastAPI was first released, this was the only way to add runtime metadata to a parameter in Python. But now there is a better way to do this! In Xpresso this same declaration would look like param: FromPath[str] or param: Annotated[str, Path()] (the former is just syntactic sugar for the latter). As you see more usages of Annoated you will get used to it. But for now all you need to know is that param: Annotated[str, Path()] is pretty much equivalent to param: str = Path() . One of the main advantages to using Annotated is composability: multiple tools/libraries can include metadata together without conflict. For example, we can included information for both Xpresso and Pydantic using param: Annotated[str, Path(), Field(min_length=1) . This is in contrast to FastAPI where Query() and friends are actually subclasses of Pydantic's Field() , which couples the web framework to Pydantic and adds complexity into Query() , Path() , etc. that is not really related to them directly. To see an example of this in action, head over to the Path Parameters section of our documentation.","title":"Python Types"},{"location":"types/#typing-in-python","text":"This documentation assumes that you are familiar with type annotations in Python. If you are not, that is okay! There are a lot of excellent guides out there to get you started: RealPython's Python Type Checking guide FastAPI's introduction to python types","title":"Typing in Python"},{"location":"types/#runtime-types-reflection","text":"Most languages loose a lot of their type information at runtime. This can range between complete loss of type information (like TypeScript) or only weak support for runtime reflection (Golang). Python stands out for it's strong support for typing information at runtime (often called reflection ). Because of Python's dynamic runtime behavior, it is possible to read types and modify the runtime behavior of the program.","title":"Runtime types (reflection)"},{"location":"types/#annotated-and-parameter-metadata","text":"Python 3.9 (via PEP 593 ) introduced the Annotated typing construct. Since it's release in Python 3.9, this construct has been backported to older Python versions via the typing_extensions package. So it is available all the way back to Python 3.7. Xpresso uses Annotated extensively since it provides a composable, cohesive and widely supported pattern for attaching metadata for function parameters and class field declarations that is available at runtime. If you've used FastAPI, you may be used to declaring things like param: str = Path(gt=0) . When FastAPI was first released, this was the only way to add runtime metadata to a parameter in Python. But now there is a better way to do this! In Xpresso this same declaration would look like param: FromPath[str] or param: Annotated[str, Path()] (the former is just syntactic sugar for the latter). As you see more usages of Annoated you will get used to it. But for now all you need to know is that param: Annotated[str, Path()] is pretty much equivalent to param: str = Path() . One of the main advantages to using Annotated is composability: multiple tools/libraries can include metadata together without conflict. For example, we can included information for both Xpresso and Pydantic using param: Annotated[str, Path(), Field(min_length=1) . This is in contrast to FastAPI where Query() and friends are actually subclasses of Pydantic's Field() , which couples the web framework to Pydantic and adds complexity into Query() , Path() , etc. that is not really related to them directly. To see an example of this in action, head over to the Path Parameters section of our documentation.","title":"Annotated and parameter metadata"},{"location":"tutorial/body/","text":"Request Body Xpresso has a rich system of extractors to extract and parse request bodies. These help give you type safety, data validation and automatic OpenAPI spec generation. We'll start off using JSON as an example since this is one of the most common types of request bodies. But as you will see in the later chapters, a lot of the same concepts apply forms and multipart requests. Declaring a body schema First, we need to define the schema of our body and give Xpresso a data structure to extract our body into. This data structure can be a built in type (like int or str ), a collection (like dict or list ) or a Pydantic model. Info Although Xpresso makes extensive use of Pydantic and no other similar libraries are supported out of the box, there is no reason why support could not be implemented. As you will see later, writing a custom extractor is pretty easy. It just doesn't make sense to provide out of the box integration with dozens of libraries, so we chose Pydantic. For most use cases, you'll want to stick with a Pydantic model. Declaring a Pydantic model is simple. Start by importing BaseModel from Pydantic and declaring the fields of the model using type annotations: from typing import Dict , Optional from pydantic import BaseModel from xpresso import App , FromJson , Path class Item ( BaseModel ): name : str price : float tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) Then we declare add the FromJson[...] marker (which is syntactic sugar for Annotated[..., Json()] ) to a paramter in our path function: from typing import Dict , Optional from pydantic import BaseModel from xpresso import App , FromJson , Path class Item ( BaseModel ): name : str price : float tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) That's it! Now when you receive a request it will be read as JSON and then passed to Pydantic for validation and parsing. Your function will receive a validated instance of Item . OpenAPI and SwaggerUI Just like path and query parameters, request bodies automatically generate OpenAPI documentation: Constraints and Customization Pydantic supports rich validation and customization of model schemas. For in depth information on the topic, see Pydantic 's docs. But here is a quick example of how this can work in Xpresso. First, import Field from Pydantic and Annotated : from typing import Dict , Optional from pydantic import BaseModel , Field from xpresso import App , FromJson , Path from xpresso.typing import Annotated class Item ( BaseModel ): name : str price : Annotated [ float , Field ( gt = 0 , description = \"Item price without tax. Must be greater than zero.\" , ), ] tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and [typing_extensions] otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Now use Field() inside of Annotated[...] to attach validation and schema customziation metadata to the price field: from typing import Dict , Optional from pydantic import BaseModel , Field from xpresso import App , FromJson , Path from xpresso.typing import Annotated class Item ( BaseModel ): name : str price : Annotated [ float , Field ( gt = 0 , description = \"Item price without tax. Must be greater than zero.\" , ), ] tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) Tip Pydantic also supports the syntax field_name: str = Field(...) , but we encourage youto get used to using Annotated instead. As you will see in later chapters about forms and multipart requests, this will allow you to mix in Pydantic's validation and schema customization with Xpresso's extractor system. That said, for JSON bodies using field_name: str = Field(...) will work just fine. Using builtin types While you will probably need Pydantic models for complex cases, in many simple cases you can get away with just using the standard library's container types. For example, you can declare that a JSON body is a list of integers: from typing import Dict , List from xpresso import App , FromJson , Path async def count_items ( item_counts : FromJson [ List [ int ]]) -> Dict [ str , int ]: return { \"total\" : sum ( item_counts )} app = App ( routes = [ Path ( \"/items/count\" , put = count_items , ) ] ) Mixing builtins with Pydantic You can also wrap an existing Pydantic model in a container, for example to receive a list of items: from typing import Dict , List , Optional from pydantic import BaseModel from xpresso import App , FromJson , Path class Item ( BaseModel ): name : str price : float tax : Optional [ float ] = None async def create_receipt ( items : FromJson [ List [ Item ]]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 ) for item in items } app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] )","title":"Request Body"},{"location":"tutorial/body/#request-body","text":"Xpresso has a rich system of extractors to extract and parse request bodies. These help give you type safety, data validation and automatic OpenAPI spec generation. We'll start off using JSON as an example since this is one of the most common types of request bodies. But as you will see in the later chapters, a lot of the same concepts apply forms and multipart requests.","title":"Request Body"},{"location":"tutorial/body/#declaring-a-body-schema","text":"First, we need to define the schema of our body and give Xpresso a data structure to extract our body into. This data structure can be a built in type (like int or str ), a collection (like dict or list ) or a Pydantic model. Info Although Xpresso makes extensive use of Pydantic and no other similar libraries are supported out of the box, there is no reason why support could not be implemented. As you will see later, writing a custom extractor is pretty easy. It just doesn't make sense to provide out of the box integration with dozens of libraries, so we chose Pydantic. For most use cases, you'll want to stick with a Pydantic model. Declaring a Pydantic model is simple. Start by importing BaseModel from Pydantic and declaring the fields of the model using type annotations: from typing import Dict , Optional from pydantic import BaseModel from xpresso import App , FromJson , Path class Item ( BaseModel ): name : str price : float tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) Then we declare add the FromJson[...] marker (which is syntactic sugar for Annotated[..., Json()] ) to a paramter in our path function: from typing import Dict , Optional from pydantic import BaseModel from xpresso import App , FromJson , Path class Item ( BaseModel ): name : str price : float tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) That's it! Now when you receive a request it will be read as JSON and then passed to Pydantic for validation and parsing. Your function will receive a validated instance of Item .","title":"Declaring a body schema"},{"location":"tutorial/body/#openapi-and-swaggerui","text":"Just like path and query parameters, request bodies automatically generate OpenAPI documentation:","title":"OpenAPI and SwaggerUI"},{"location":"tutorial/body/#constraints-and-customization","text":"Pydantic supports rich validation and customization of model schemas. For in depth information on the topic, see Pydantic 's docs. But here is a quick example of how this can work in Xpresso. First, import Field from Pydantic and Annotated : from typing import Dict , Optional from pydantic import BaseModel , Field from xpresso import App , FromJson , Path from xpresso.typing import Annotated class Item ( BaseModel ): name : str price : Annotated [ float , Field ( gt = 0 , description = \"Item price without tax. Must be greater than zero.\" , ), ] tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and [typing_extensions] otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Now use Field() inside of Annotated[...] to attach validation and schema customziation metadata to the price field: from typing import Dict , Optional from pydantic import BaseModel , Field from xpresso import App , FromJson , Path from xpresso.typing import Annotated class Item ( BaseModel ): name : str price : Annotated [ float , Field ( gt = 0 , description = \"Item price without tax. Must be greater than zero.\" , ), ] tax : Optional [ float ] = None async def create_receipt ( item : FromJson [ Item ]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 )} app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] ) Tip Pydantic also supports the syntax field_name: str = Field(...) , but we encourage youto get used to using Annotated instead. As you will see in later chapters about forms and multipart requests, this will allow you to mix in Pydantic's validation and schema customization with Xpresso's extractor system. That said, for JSON bodies using field_name: str = Field(...) will work just fine.","title":"Constraints and Customization"},{"location":"tutorial/body/#using-builtin-types","text":"While you will probably need Pydantic models for complex cases, in many simple cases you can get away with just using the standard library's container types. For example, you can declare that a JSON body is a list of integers: from typing import Dict , List from xpresso import App , FromJson , Path async def count_items ( item_counts : FromJson [ List [ int ]]) -> Dict [ str , int ]: return { \"total\" : sum ( item_counts )} app = App ( routes = [ Path ( \"/items/count\" , put = count_items , ) ] )","title":"Using builtin types"},{"location":"tutorial/body/#mixing-builtins-with-pydantic","text":"You can also wrap an existing Pydantic model in a container, for example to receive a list of items: from typing import Dict , List , Optional from pydantic import BaseModel from xpresso import App , FromJson , Path class Item ( BaseModel ): name : str price : float tax : Optional [ float ] = None async def create_receipt ( items : FromJson [ List [ Item ]]) -> Dict [ str , float ]: return { item . name : item . price + ( item . tax or 0 ) for item in items } app = App ( routes = [ Path ( \"/items/\" , post = create_receipt , ) ] )","title":"Mixing builtins with Pydantic"},{"location":"tutorial/cookie_params/","text":"Cookie Parameters Cookies parameters are declared the same way as Query and Path parameters: from typing import Dict , Optional from xpresso import App , FromCookie , Path async def read_items ( advertiser_id : FromCookie [ Optional [ int ]] = None , ) -> Dict [ str , Optional [ int ]]: return { \"advertiser_id\" : advertiser_id } app = App ( routes = [ Path ( \"/items/\" , get = read_items , ) ] ) Repeated Cookies Serialization and Parsing","title":"Cookie Parameters"},{"location":"tutorial/cookie_params/#cookie-parameters","text":"Cookies parameters are declared the same way as Query and Path parameters: from typing import Dict , Optional from xpresso import App , FromCookie , Path async def read_items ( advertiser_id : FromCookie [ Optional [ int ]] = None , ) -> Dict [ str , Optional [ int ]]: return { \"advertiser_id\" : advertiser_id } app = App ( routes = [ Path ( \"/items/\" , get = read_items , ) ] )","title":"Cookie Parameters"},{"location":"tutorial/cookie_params/#repeated-cookies","text":"","title":"Repeated Cookies"},{"location":"tutorial/cookie_params/#serialization-and-parsing","text":"","title":"Serialization and Parsing"},{"location":"tutorial/di/","text":"Dependency Injection Xpresso has a powerful dependency injection system, backed by di . You can inject classes, callable class instances, sync and async functions and context managers. These can be chained, and dependencies are auto wired. In this example, we'll create a common set of query parameters that can be collected and used from multiple endpoints. from typing import Any , Dict , Optional from xpresso import App , FromQuery , Path from xpresso.dependencies.models import Dependant from xpresso.typing import Annotated async def common_parameters ( q : FromQuery [ Optional [ str ]] = None , skip : FromQuery [ int ] = 0 , limit : FromQuery [ int ] = 100 , ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } async def read_items ( commons : Annotated [ Dict [ str , Any ], Dependant ( common_parameters )] ) -> Dict [ str , Any ]: return commons async def read_users ( commons : Annotated [ Dict [ str , Any ], Dependant ( common_parameters )] ) -> Dict [ str , Any ]: return commons app = App ( routes = [ Path ( path = \"/items/\" , get = read_items ), Path ( path = \"/users/\" , get = read_users ), ] ) You are encouraged to run this example by copying it to a main.py file and running it with uvicorn main:app . As always, you can head over to http://localhost:8000/docs to see the live docs. As it turns out, FromQuery is just a dependency that extracts a query paratemeter from the request, parses it into the type declared via the type annotation and then injects it into the function. So really, we are alaready using nested dependencies! Xpresso supports arbitrarily deep nested dependency graphs. Depending on abstractions Binds can be used to depend on an abstract interface and inject an implementation at the main entrypoint. import sys from typing import Any if sys . version_info < ( 3 , 8 ): from typing_extensions import Protocol else : from typing import Protocol from xpresso import App , FromPath , Path from xpresso.dependencies.models import Dependant class DatabaseProtocol ( Protocol ): def execute ( self , query : str ) -> Any : ... # Declare our endpoints async def delete_user ( name : FromPath [ str ], db : DatabaseProtocol ) -> None : db . execute ( f \"DELETE { name } \" ) app = App ( routes = [ Path ( \"/users/ {name} \" , delete = delete_user )]) # Implement a \"real\" database class RealDatabase : def execute ( self , query : str ) -> Any : print ( query ) # or some real databse stuff # In production, we bind this \"real\" database app . container . bind ( Dependant ( RealDatabase ), DatabaseProtocol ) Substituting dependencies in tests Let's write a small test for the example above: import sys from typing import Any , List if sys . version_info < ( 3 , 8 ): from typing_extensions import Protocol else : from typing import Protocol from xpresso import App , FromPath , Path from xpresso.dependencies.models import Dependant from xpresso.testclient import TestClient class DatabaseProtocol ( Protocol ): def execute ( self , query : str ) -> Any : ... # Declare our endpoints async def delete_user ( name : FromPath [ str ], db : DatabaseProtocol ) -> None : db . execute ( f \"DELETE { name } \" ) app = App ( routes = [ Path ( \"/users/ {name} \" , delete = delete_user )]) # Implement a \"test\" database class TestDatabase : def __init__ ( self ) -> None : self . logger : List [ str ] = [] def execute ( self , query : str ) -> Any : self . logger . append ( query ) def example_test () -> None : db = TestDatabase () # In tests, we bind this \"test\" database with app . container . bind ( Dependant ( lambda : db ), DatabaseProtocol ): client = TestClient ( app ) client . delete ( \"/users/john\" ) assert db . logger == [ \"DELETE john\" ] Here we use bind() as a context manager to make sure this tests's state does not leak into other tests. Lifespan dependencies You can use dependencies in lifespan events, and also cache these dependencies for endpoints: from xpresso import App class DatabaseConnection : pass async def lifespan ( connection : DatabaseConnection ): assert isinstance ( connection , DatabaseConnection ) app = App ( lifespan = lifespan ) App scoped dependencies Dependencies can belong to the \"endpoint\" scope (the default), the \"connection\" scope (available after the endpoint has executed up until the response is sent; can be used to log responses for example) or the \"app\" scope (bound to the lifespan events of the application). from dataclasses import dataclass from xpresso import App , Dependant , Path from xpresso.typing import Annotated @dataclass class Config : host : str async def root ( # we will always get the same instance of Config config : Annotated [ Config , Dependant ( Config , scope = \"app\" )] ) -> str : return f \"Hello from { config . host } !\" app = App ( routes = [ Path ( path = \"/\" , get = root )])","title":"Dependency Injection"},{"location":"tutorial/di/#dependency-injection","text":"Xpresso has a powerful dependency injection system, backed by di . You can inject classes, callable class instances, sync and async functions and context managers. These can be chained, and dependencies are auto wired. In this example, we'll create a common set of query parameters that can be collected and used from multiple endpoints. from typing import Any , Dict , Optional from xpresso import App , FromQuery , Path from xpresso.dependencies.models import Dependant from xpresso.typing import Annotated async def common_parameters ( q : FromQuery [ Optional [ str ]] = None , skip : FromQuery [ int ] = 0 , limit : FromQuery [ int ] = 100 , ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } async def read_items ( commons : Annotated [ Dict [ str , Any ], Dependant ( common_parameters )] ) -> Dict [ str , Any ]: return commons async def read_users ( commons : Annotated [ Dict [ str , Any ], Dependant ( common_parameters )] ) -> Dict [ str , Any ]: return commons app = App ( routes = [ Path ( path = \"/items/\" , get = read_items ), Path ( path = \"/users/\" , get = read_users ), ] ) You are encouraged to run this example by copying it to a main.py file and running it with uvicorn main:app . As always, you can head over to http://localhost:8000/docs to see the live docs. As it turns out, FromQuery is just a dependency that extracts a query paratemeter from the request, parses it into the type declared via the type annotation and then injects it into the function. So really, we are alaready using nested dependencies! Xpresso supports arbitrarily deep nested dependency graphs.","title":"Dependency Injection"},{"location":"tutorial/di/#depending-on-abstractions","text":"Binds can be used to depend on an abstract interface and inject an implementation at the main entrypoint. import sys from typing import Any if sys . version_info < ( 3 , 8 ): from typing_extensions import Protocol else : from typing import Protocol from xpresso import App , FromPath , Path from xpresso.dependencies.models import Dependant class DatabaseProtocol ( Protocol ): def execute ( self , query : str ) -> Any : ... # Declare our endpoints async def delete_user ( name : FromPath [ str ], db : DatabaseProtocol ) -> None : db . execute ( f \"DELETE { name } \" ) app = App ( routes = [ Path ( \"/users/ {name} \" , delete = delete_user )]) # Implement a \"real\" database class RealDatabase : def execute ( self , query : str ) -> Any : print ( query ) # or some real databse stuff # In production, we bind this \"real\" database app . container . bind ( Dependant ( RealDatabase ), DatabaseProtocol )","title":"Depending on abstractions"},{"location":"tutorial/di/#substituting-dependencies-in-tests","text":"Let's write a small test for the example above: import sys from typing import Any , List if sys . version_info < ( 3 , 8 ): from typing_extensions import Protocol else : from typing import Protocol from xpresso import App , FromPath , Path from xpresso.dependencies.models import Dependant from xpresso.testclient import TestClient class DatabaseProtocol ( Protocol ): def execute ( self , query : str ) -> Any : ... # Declare our endpoints async def delete_user ( name : FromPath [ str ], db : DatabaseProtocol ) -> None : db . execute ( f \"DELETE { name } \" ) app = App ( routes = [ Path ( \"/users/ {name} \" , delete = delete_user )]) # Implement a \"test\" database class TestDatabase : def __init__ ( self ) -> None : self . logger : List [ str ] = [] def execute ( self , query : str ) -> Any : self . logger . append ( query ) def example_test () -> None : db = TestDatabase () # In tests, we bind this \"test\" database with app . container . bind ( Dependant ( lambda : db ), DatabaseProtocol ): client = TestClient ( app ) client . delete ( \"/users/john\" ) assert db . logger == [ \"DELETE john\" ] Here we use bind() as a context manager to make sure this tests's state does not leak into other tests.","title":"Substituting dependencies in tests"},{"location":"tutorial/di/#lifespan-dependencies","text":"You can use dependencies in lifespan events, and also cache these dependencies for endpoints: from xpresso import App class DatabaseConnection : pass async def lifespan ( connection : DatabaseConnection ): assert isinstance ( connection , DatabaseConnection ) app = App ( lifespan = lifespan )","title":"Lifespan dependencies"},{"location":"tutorial/di/#app-scoped-dependencies","text":"Dependencies can belong to the \"endpoint\" scope (the default), the \"connection\" scope (available after the endpoint has executed up until the response is sent; can be used to log responses for example) or the \"app\" scope (bound to the lifespan events of the application). from dataclasses import dataclass from xpresso import App , Dependant , Path from xpresso.typing import Annotated @dataclass class Config : host : str async def root ( # we will always get the same instance of Config config : Annotated [ Config , Dependant ( Config , scope = \"app\" )] ) -> str : return f \"Hello from { config . host } !\" app = App ( routes = [ Path ( path = \"/\" , get = root )])","title":"App scoped dependencies"},{"location":"tutorial/files/","text":"Files You can read the request body directly into a file or bytes. This will read the data from the top level request body, and can only support 1 file. To receive multiple files, see the multipart/form-data documentation . from xpresso import App , FromFile , Path , UploadFile async def count_bytes_in_file ( file : FromFile [ UploadFile ]) -> int : return len ( await file . read ()) app = App ( routes = [ Path ( path = \"/count-bytes\" , put = count_bytes_in_file )]) Note UploadFile is a class provided by Starlette that buffers the data in memory and overflows to disk if the data is larger than a predefined threashold. This prevents a large file from exhausting your hardware's memory. As bytes Xpresso can read the entire file into memory if you'd like: from xpresso import App , FromFile , Path async def count_bytes_in_file ( data : FromFile [ bytes ]) -> int : return len ( data ) app = App ( routes = [ Path ( path = \"/count-bytes\" , put = count_bytes_in_file )]) This can be convenient if you know the files are not large. Setting the content-type You can set the media type via the media_type parameter to File() and enforce it via the enforce_media_type parameter: from xpresso import App , File , Path , UploadFile from xpresso.typing import Annotated async def count_image_bytes ( file : Annotated [ UploadFile , File ( media_type = \"image/*\" , enforce_media_type = True )] ) -> int : return len ( await file . read ()) app = App ( routes = [ Path ( path = \"/count-bytes\" , put = count_image_bytes )]) Media types can be a media type (e.g. image/png ) or a media type range (e.g. image/* ). If you do not explicitly set the media type, all media types are accepted. Once you set an explicit media type, that media type in the requests' Content-Type header will be validated on incoming requests, but this behavior can be disabled via the enforce_media_type parameter to File() .","title":"File Uploads"},{"location":"tutorial/files/#files","text":"You can read the request body directly into a file or bytes. This will read the data from the top level request body, and can only support 1 file. To receive multiple files, see the multipart/form-data documentation . from xpresso import App , FromFile , Path , UploadFile async def count_bytes_in_file ( file : FromFile [ UploadFile ]) -> int : return len ( await file . read ()) app = App ( routes = [ Path ( path = \"/count-bytes\" , put = count_bytes_in_file )]) Note UploadFile is a class provided by Starlette that buffers the data in memory and overflows to disk if the data is larger than a predefined threashold. This prevents a large file from exhausting your hardware's memory.","title":"Files"},{"location":"tutorial/files/#as-bytes","text":"Xpresso can read the entire file into memory if you'd like: from xpresso import App , FromFile , Path async def count_bytes_in_file ( data : FromFile [ bytes ]) -> int : return len ( data ) app = App ( routes = [ Path ( path = \"/count-bytes\" , put = count_bytes_in_file )]) This can be convenient if you know the files are not large.","title":"As bytes"},{"location":"tutorial/files/#setting-the-content-type","text":"You can set the media type via the media_type parameter to File() and enforce it via the enforce_media_type parameter: from xpresso import App , File , Path , UploadFile from xpresso.typing import Annotated async def count_image_bytes ( file : Annotated [ UploadFile , File ( media_type = \"image/*\" , enforce_media_type = True )] ) -> int : return len ( await file . read ()) app = App ( routes = [ Path ( path = \"/count-bytes\" , put = count_image_bytes )]) Media types can be a media type (e.g. image/png ) or a media type range (e.g. image/* ). If you do not explicitly set the media type, all media types are accepted. Once you set an explicit media type, that media type in the requests' Content-Type header will be validated on incoming requests, but this behavior can be disabled via the enforce_media_type parameter to File() .","title":"Setting the content-type"},{"location":"tutorial/forms/","text":"Forms To extract forms in Xpresso, you start by declaring a data structure to unpack the form into. The fields of the datastructure correspond to the fields of the form data. The datastructure can be almost anything, including dataclasses, pydantic models and regular Python classes. from dataclasses import dataclass from typing import List from pydantic import BaseModel from xpresso import App , ExtractField , FromFormData , FromFormField , FromJson , Path class JsonModel ( BaseModel ): foo : str @dataclass ( frozen = True ) class FormDataModel : name : str # implicit FromFormField[str] tags : FromFormField [ List [ str ]] json_data : ExtractField [ FromJson [ JsonModel ]] async def compare_json_to_form ( form : FromFormData [ FormDataModel ]) -> bool : return form . json_data . foo in form . tags app = App ( routes = [ Path ( path = \"/form\" , post = compare_json_to_form )]) This request extracts a application/x-www-form-urlencoded request into a FormDataModel object. Note Form fields ( FromFormField ) are extracted from the form directly, but things like JSON or files need to be yanked out of a specific field before they are parsed/extracted. So for non form-native fields (anything except FromFormField ) you need to wrap it in ExtractField . Form serialization Xpresso fully supports the OpenAPI parameter serialization standard. You can customize how extraction ocurrs using the style and explode keyword arguments to FormField() : from dataclasses import dataclass from typing import List from xpresso import App , FormEncodedField , FromFormData , Path from xpresso.typing import Annotated @dataclass ( frozen = True ) class FormDataModel : tags : Annotated [ List [ str ], FormEncodedField ( style = \"spaceDelimited\" , explode = False )] async def echo_tags ( form : FromFormData [ FormDataModel ]) -> List [ str ]: return form . tags # returned as JSON app = App ( routes = [ Path ( path = \"/echo-tags\" , post = echo_tags )]) Multipart requests Multipart requests ( multipart/form-data ) can be parsed almost identically to application/x-www-form-urlencoded . You can't upload mixed files and data in an application/x-www-form-urlencoded request, so you'll need to use a Multipart request. Multipart requests even support multiple files: from dataclasses import dataclass from typing import List from pydantic import BaseModel from xpresso import ( App , ExtractRepeatedField , FromFile , FromFormField , FromMultipart , Path , UploadFile , ) class JsonModel ( BaseModel ): foo : str @dataclass ( frozen = True ) class FormDataModel : name : str # implicit FromFormField[str] tags : FromFormField [ List [ str ]] files : ExtractRepeatedField [ FromFile [ List [ UploadFile ]]] class UserUploadMetadata ( BaseModel ): name : str tags : List [ str ] nbytes : int async def upload_data ( form : FromMultipart [ FormDataModel ]) -> UserUploadMetadata : nbytes = 0 for file in form . files : nbytes += len ( await file . read ()) return UserUploadMetadata ( name = form . name , tags = form . tags , nbytes = nbytes , ) app = App ( routes = [ Path ( path = \"/form\" , post = upload_data )]) Note Fields in a application/x-www-form-urlencoded or multipart/form-data request can be repeated. This just means that a field of the same name appears more than once in the request. Often this is used to upload multiple files, such as in the example above. To declare repeated fields we need to do two things: 1. Use ExtractRepeatedField instead of ExtractField . 1. Make sure our type is actually a List/Tuple/Set (any sequence will do).","title":"Forms"},{"location":"tutorial/forms/#forms","text":"To extract forms in Xpresso, you start by declaring a data structure to unpack the form into. The fields of the datastructure correspond to the fields of the form data. The datastructure can be almost anything, including dataclasses, pydantic models and regular Python classes. from dataclasses import dataclass from typing import List from pydantic import BaseModel from xpresso import App , ExtractField , FromFormData , FromFormField , FromJson , Path class JsonModel ( BaseModel ): foo : str @dataclass ( frozen = True ) class FormDataModel : name : str # implicit FromFormField[str] tags : FromFormField [ List [ str ]] json_data : ExtractField [ FromJson [ JsonModel ]] async def compare_json_to_form ( form : FromFormData [ FormDataModel ]) -> bool : return form . json_data . foo in form . tags app = App ( routes = [ Path ( path = \"/form\" , post = compare_json_to_form )]) This request extracts a application/x-www-form-urlencoded request into a FormDataModel object. Note Form fields ( FromFormField ) are extracted from the form directly, but things like JSON or files need to be yanked out of a specific field before they are parsed/extracted. So for non form-native fields (anything except FromFormField ) you need to wrap it in ExtractField .","title":"Forms"},{"location":"tutorial/forms/#form-serialization","text":"Xpresso fully supports the OpenAPI parameter serialization standard. You can customize how extraction ocurrs using the style and explode keyword arguments to FormField() : from dataclasses import dataclass from typing import List from xpresso import App , FormEncodedField , FromFormData , Path from xpresso.typing import Annotated @dataclass ( frozen = True ) class FormDataModel : tags : Annotated [ List [ str ], FormEncodedField ( style = \"spaceDelimited\" , explode = False )] async def echo_tags ( form : FromFormData [ FormDataModel ]) -> List [ str ]: return form . tags # returned as JSON app = App ( routes = [ Path ( path = \"/echo-tags\" , post = echo_tags )])","title":"Form serialization"},{"location":"tutorial/forms/#multipart-requests","text":"Multipart requests ( multipart/form-data ) can be parsed almost identically to application/x-www-form-urlencoded . You can't upload mixed files and data in an application/x-www-form-urlencoded request, so you'll need to use a Multipart request. Multipart requests even support multiple files: from dataclasses import dataclass from typing import List from pydantic import BaseModel from xpresso import ( App , ExtractRepeatedField , FromFile , FromFormField , FromMultipart , Path , UploadFile , ) class JsonModel ( BaseModel ): foo : str @dataclass ( frozen = True ) class FormDataModel : name : str # implicit FromFormField[str] tags : FromFormField [ List [ str ]] files : ExtractRepeatedField [ FromFile [ List [ UploadFile ]]] class UserUploadMetadata ( BaseModel ): name : str tags : List [ str ] nbytes : int async def upload_data ( form : FromMultipart [ FormDataModel ]) -> UserUploadMetadata : nbytes = 0 for file in form . files : nbytes += len ( await file . read ()) return UserUploadMetadata ( name = form . name , tags = form . tags , nbytes = nbytes , ) app = App ( routes = [ Path ( path = \"/form\" , post = upload_data )]) Note Fields in a application/x-www-form-urlencoded or multipart/form-data request can be repeated. This just means that a field of the same name appears more than once in the request. Often this is used to upload multiple files, such as in the example above. To declare repeated fields we need to do two things: 1. Use ExtractRepeatedField instead of ExtractField . 1. Make sure our type is actually a List/Tuple/Set (any sequence will do).","title":"Multipart requests"},{"location":"tutorial/header_params/","text":"Header Parameters Header parameters are declared the same way as Query and Path parameters: from typing import Dict , Optional from xpresso import App , FromHeader , Path async def read_items ( accept_language : FromHeader [ Optional [ str ]] = None , ) -> Dict [ str , Optional [ str ]]: return { \"Accept-Language\" : accept_language } app = App ( routes = [ Path ( \"/items/\" , get = read_items , ) ] ) Underscore conversion Headers names are usually composed of several words separated by hyphens ( \"-\" ). But Python veriable names cannot contain hyphens. Since Xpresso automatically derives the header names from the parameter names, this creates a problem. To get around this, Xpresso automatically converts parameter name underscores ( \"_\" ) to hyphens ( \"-\" ). This is controlled using the convert_underscores parameter to HeaderParam(...) : from typing import Dict , Optional from xpresso import App , HeaderParam , Path from xpresso.typing import Annotated async def read_items ( some_header : Annotated [ str , HeaderParam ( convert_underscores = False )] ) -> Dict [ str , Optional [ str ]]: return { \"some_header\" : some_header } app = App ( routes = [ Path ( \"/items/\" , get = read_items , ) ] ) Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and [typing_extensions] otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Warning It is pretty uncommon to use headers with underscores. You should probably think twice about setting convert_underscores=False and test that it doesn't break your clients, proxies, etc. Repeated Headers Serialization and Parsing","title":"Header Parameters"},{"location":"tutorial/header_params/#header-parameters","text":"Header parameters are declared the same way as Query and Path parameters: from typing import Dict , Optional from xpresso import App , FromHeader , Path async def read_items ( accept_language : FromHeader [ Optional [ str ]] = None , ) -> Dict [ str , Optional [ str ]]: return { \"Accept-Language\" : accept_language } app = App ( routes = [ Path ( \"/items/\" , get = read_items , ) ] )","title":"Header Parameters"},{"location":"tutorial/header_params/#underscore-conversion","text":"Headers names are usually composed of several words separated by hyphens ( \"-\" ). But Python veriable names cannot contain hyphens. Since Xpresso automatically derives the header names from the parameter names, this creates a problem. To get around this, Xpresso automatically converts parameter name underscores ( \"_\" ) to hyphens ( \"-\" ). This is controlled using the convert_underscores parameter to HeaderParam(...) : from typing import Dict , Optional from xpresso import App , HeaderParam , Path from xpresso.typing import Annotated async def read_items ( some_header : Annotated [ str , HeaderParam ( convert_underscores = False )] ) -> Dict [ str , Optional [ str ]]: return { \"some_header\" : some_header } app = App ( routes = [ Path ( \"/items/\" , get = read_items , ) ] ) Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and [typing_extensions] otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Warning It is pretty uncommon to use headers with underscores. You should probably think twice about setting convert_underscores=False and test that it doesn't break your clients, proxies, etc.","title":"Underscore conversion"},{"location":"tutorial/header_params/#repeated-headers","text":"","title":"Repeated Headers"},{"location":"tutorial/header_params/#serialization-and-parsing","text":"","title":"Serialization and Parsing"},{"location":"tutorial/minimal_app/","text":"Getting started: a minimal Xpresso app Start by making a file called main.py and fill out the following code: from xpresso import App , Path async def endpoint (): return { \"message\" : \"Hello World\" } app = App ( routes = [ Path ( path = \"/\" , get = endpoint )]) What we've done here so far is: Create an endpoint function. Create a PathItem. A PathItem represents a unique HTTP resource, and can have several http methods attached to it. Bind our endpoint function to the PathItem's GET method. Create an App instance that uses the PathItem. This is actually all we need, so you can run this using Uvicorn: uvicorn main : app Now navigate to http://localhost:8000/ and you should see {\"message\": \"Hello World\"} on your screen. Interactive Swagger Docs You can also navigate to http://localhost:8000/docs to see the OpenAPI docs, served via Swagger UI . Info Swagger UI is a collection of HTML and scripts that serve as a frontend to an OpenAPI specification. Swagger gives you an interactive UI where you can send requests and get responses from your backend, all based on the OpenAPI specification that Xpresso automatically builds for you. Since we didn't give Xpresso much info on the endpoint function's return value (it is implicitly None ) and there is no request body, there isn't much information in OpenAPI. In later chapters, you will see how we can give Xpresso more information.","title":"Minimal App"},{"location":"tutorial/minimal_app/#getting-started-a-minimal-xpresso-app","text":"Start by making a file called main.py and fill out the following code: from xpresso import App , Path async def endpoint (): return { \"message\" : \"Hello World\" } app = App ( routes = [ Path ( path = \"/\" , get = endpoint )]) What we've done here so far is: Create an endpoint function. Create a PathItem. A PathItem represents a unique HTTP resource, and can have several http methods attached to it. Bind our endpoint function to the PathItem's GET method. Create an App instance that uses the PathItem. This is actually all we need, so you can run this using Uvicorn: uvicorn main : app Now navigate to http://localhost:8000/ and you should see {\"message\": \"Hello World\"} on your screen.","title":"Getting started: a minimal Xpresso app"},{"location":"tutorial/minimal_app/#interactive-swagger-docs","text":"You can also navigate to http://localhost:8000/docs to see the OpenAPI docs, served via Swagger UI . Info Swagger UI is a collection of HTML and scripts that serve as a frontend to an OpenAPI specification. Swagger gives you an interactive UI where you can send requests and get responses from your backend, all based on the OpenAPI specification that Xpresso automatically builds for you. Since we didn't give Xpresso much info on the endpoint function's return value (it is implicitly None ) and there is no request body, there isn't much information in OpenAPI. In later chapters, you will see how we can give Xpresso more information.","title":"Interactive Swagger Docs"},{"location":"tutorial/param_constraints_and_metadata/","text":"Constraints and Metadata for Parameters Query, Path, Header and Cookie parameters benefit from Pydantic's rich validation and schema generation. You can attach extra validation and schema metadata using Pydantic's Field() . For in depth information on the topic, see Pydantic 's docs. But here is a quick example of how this can work in Xpresso. First, import Field from Pydantic and Annotated : from pydantic import Field from xpresso import App , Path , QueryParam from xpresso.typing import Annotated fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_item ( skip : Annotated [ int , QueryParam ( description = \"Count of items to skip starting from the 0th item\" ), Field ( gt = 0 ), ], limit : Annotated [ int , QueryParam (), Field ( gt = 0 , description = \"Maximum number of items to return\" ), ], ): return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_item , ), ] ) Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and [typing_extensions] otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Now use Field() inside of Annotated[...] to attach validation and schema customziation metadata to the price field: from pydantic import Field from xpresso import App , Path , QueryParam from xpresso.typing import Annotated fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_item ( skip : Annotated [ int , QueryParam ( description = \"Count of items to skip starting from the 0th item\" ), Field ( gt = 0 ), ], limit : Annotated [ int , QueryParam (), Field ( gt = 0 , description = \"Maximum number of items to return\" ), ], ): return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_item , ), ] ) Note You'll notice that there is some overlap between the parameters to QueryParam(...) and Field(...) , for example description . This is just a convenience for you, the developer, so that you don't have to import Field(...) for the most common use cases. Whenever there is a duplicate parameter, the value in QueryParam(...) is preferred with a fallback to Field(...) 's value. Tip If you are adding a lot of metadata, it may be convenient to make a [PEP 613 type alias] at the module level. For example, you can do Limit = Annotated[int, QueryParam(), Field(gt=0)] and then use that like limit: Limit in your endpoint function. This is also useful if you are re-using the same parameter in multiple function signatures or even across modules. Of course, you will get automatic validation of the gt constraints and the metadata will be reflected inthe OpenAPI schema:","title":"Parameter Constraints and Metadata"},{"location":"tutorial/param_constraints_and_metadata/#constraints-and-metadata-for-parameters","text":"Query, Path, Header and Cookie parameters benefit from Pydantic's rich validation and schema generation. You can attach extra validation and schema metadata using Pydantic's Field() . For in depth information on the topic, see Pydantic 's docs. But here is a quick example of how this can work in Xpresso. First, import Field from Pydantic and Annotated : from pydantic import Field from xpresso import App , Path , QueryParam from xpresso.typing import Annotated fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_item ( skip : Annotated [ int , QueryParam ( description = \"Count of items to skip starting from the 0th item\" ), Field ( gt = 0 ), ], limit : Annotated [ int , QueryParam (), Field ( gt = 0 , description = \"Maximum number of items to return\" ), ], ): return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_item , ), ] ) Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and [typing_extensions] otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Now use Field() inside of Annotated[...] to attach validation and schema customziation metadata to the price field: from pydantic import Field from xpresso import App , Path , QueryParam from xpresso.typing import Annotated fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_item ( skip : Annotated [ int , QueryParam ( description = \"Count of items to skip starting from the 0th item\" ), Field ( gt = 0 ), ], limit : Annotated [ int , QueryParam (), Field ( gt = 0 , description = \"Maximum number of items to return\" ), ], ): return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_item , ), ] ) Note You'll notice that there is some overlap between the parameters to QueryParam(...) and Field(...) , for example description . This is just a convenience for you, the developer, so that you don't have to import Field(...) for the most common use cases. Whenever there is a duplicate parameter, the value in QueryParam(...) is preferred with a fallback to Field(...) 's value. Tip If you are adding a lot of metadata, it may be convenient to make a [PEP 613 type alias] at the module level. For example, you can do Limit = Annotated[int, QueryParam(), Field(gt=0)] and then use that like limit: Limit in your endpoint function. This is also useful if you are re-using the same parameter in multiple function signatures or even across modules. Of course, you will get automatic validation of the gt constraints and the metadata will be reflected inthe OpenAPI schema:","title":"Constraints and Metadata for Parameters"},{"location":"tutorial/path_params/","text":"Path parameters Path parameters are declared in the route defenition, using the same foramt as formatting strings ( \"{}\" ): To tell Xpresso that you want to extract a path parameter and inject it into your function, use FromPath . This is just a marker that tells Xpresso how to inject the value, it has no effect on the function if it is called directly. from typing import Dict from xpresso import App , FromPath , Path async def read_item ( item_id : FromPath [ str ]) -> Dict [ str , str ]: return { \"item_id\" : item_id } app = App ( routes = [ Path ( path = \"/items/ {item_id} \" , get = read_item , ), ] ) If you run this example using Uvicorn, you can go to http://127.0.0.1:8000/items/1234 ( 1234 is an arbitrary string) and you'll get a JSON response in your browser like: { \"item_id\" : \"1234\" } Type conversions Xpresso uses type annotations from your parameters to do conversions and parsing. If we modify the example above to expect an int , Xpresso will convert the path parameter (which is always a string, since it is coming from a URL) int an int and automatically return an error response if it is not a valid integer: from typing import Dict from xpresso import App , FromPath , Path async def read_item ( item_id : FromPath [ int ]) -> Dict [ str , int ]: return { \"item_id\" : item_id } app = App ( routes = [ Path ( path = \"/items/ {item_id} \" , get = read_item , ), ] ) Now if you navigate to http://127.0.0.1:8000/items/1234 (the same URL as before) you will get back a response with an integer instead of a string: { \"item_id\" : 1234 } Let's try passing in something that is not an integer. Navigate to http://127.0.0.1:8000/items/foobarbaz and you'll get back: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } Under the hood, we use Pydantic for this parsing and validation. So you can also use Pydantic constraints: from typing import Dict from pydantic import Field from xpresso import App , Path , PathParam from xpresso.typing import Annotated async def read_item ( item_id : Annotated [ int , PathParam (), Field ( gt = 0 )] ) -> Dict [ str , int ]: return { \"item_id\" : item_id } app = App ( routes = [ Path ( path = \"/items/ {item_id} \" , get = read_item , ), ] ) Info This is probably a good spot to digress and talk about Annotated since you may be confused if you are not familiar with it. If you've used FastAPI, you may be used to declaring things like param: str = Path(gt=0) . In Xpresso, this turns into param: Annotated[str, Path(), Field(gt=0)] . For more background on Annoated itself, see the Python Types section of our docs. Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and typing_extensions otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Navigating to http://127.0.0.1:8000/items/1 (a positive value) will give you: { \"item_id\" : 1 } But if you try http://127.0.0.1:8000/items/-1 (a negative value): { \"detail\" : [ { \"ctx\" : { \"limit_value\" : 0 }, \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"ensure this value is greater than 0\" , \"type\" : \"value_error.number.not_gt\" } ] } OpenAPI documentation If you run one of the examples above and navigate to http://127.0.0.1:8000/docs you'll see the OpenAPI documentation. It should look something like: Deserialziation and parsing Xpresso offers full support for the the OpenAPI parameter serialization spec . You can control the serialization style using the style and explode arguments to Path() : The Python type can be a scalar value, a collection (like a list or dict) or even a Pydantic model (for object-valued parameters). from typing import List from xpresso import App , Path , PathParam from xpresso.typing import Annotated async def read_items ( items : Annotated [ List [ int ], PathParam ( explode = True , style = \"matrix\" )] ) -> List [ int ]: return items app = App ( routes = [ Path ( path = \"/items/ {items} \" , get = read_items , ), ] ) Navigating to http://127.0.0.1:8000/items/;items=1;items=2;items=3 will return the following JSON: [ 1 , 2 , 3 ]","title":"Path Parameters"},{"location":"tutorial/path_params/#path-parameters","text":"Path parameters are declared in the route defenition, using the same foramt as formatting strings ( \"{}\" ): To tell Xpresso that you want to extract a path parameter and inject it into your function, use FromPath . This is just a marker that tells Xpresso how to inject the value, it has no effect on the function if it is called directly. from typing import Dict from xpresso import App , FromPath , Path async def read_item ( item_id : FromPath [ str ]) -> Dict [ str , str ]: return { \"item_id\" : item_id } app = App ( routes = [ Path ( path = \"/items/ {item_id} \" , get = read_item , ), ] ) If you run this example using Uvicorn, you can go to http://127.0.0.1:8000/items/1234 ( 1234 is an arbitrary string) and you'll get a JSON response in your browser like: { \"item_id\" : \"1234\" }","title":"Path parameters"},{"location":"tutorial/path_params/#type-conversions","text":"Xpresso uses type annotations from your parameters to do conversions and parsing. If we modify the example above to expect an int , Xpresso will convert the path parameter (which is always a string, since it is coming from a URL) int an int and automatically return an error response if it is not a valid integer: from typing import Dict from xpresso import App , FromPath , Path async def read_item ( item_id : FromPath [ int ]) -> Dict [ str , int ]: return { \"item_id\" : item_id } app = App ( routes = [ Path ( path = \"/items/ {item_id} \" , get = read_item , ), ] ) Now if you navigate to http://127.0.0.1:8000/items/1234 (the same URL as before) you will get back a response with an integer instead of a string: { \"item_id\" : 1234 } Let's try passing in something that is not an integer. Navigate to http://127.0.0.1:8000/items/foobarbaz and you'll get back: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } Under the hood, we use Pydantic for this parsing and validation. So you can also use Pydantic constraints: from typing import Dict from pydantic import Field from xpresso import App , Path , PathParam from xpresso.typing import Annotated async def read_item ( item_id : Annotated [ int , PathParam (), Field ( gt = 0 )] ) -> Dict [ str , int ]: return { \"item_id\" : item_id } app = App ( routes = [ Path ( path = \"/items/ {item_id} \" , get = read_item , ), ] ) Info This is probably a good spot to digress and talk about Annotated since you may be confused if you are not familiar with it. If you've used FastAPI, you may be used to declaring things like param: str = Path(gt=0) . In Xpresso, this turns into param: Annotated[str, Path(), Field(gt=0)] . For more background on Annoated itself, see the Python Types section of our docs. Tip The import from Xpresso.typing import Annotated is just a convenience import. All it does is import Annotated from typing if your Python version is >= 3.9 and typing_extensions otherwise. But if you are already using Python >= 3.9, you can just replace that with from typing import Annotated . Navigating to http://127.0.0.1:8000/items/1 (a positive value) will give you: { \"item_id\" : 1 } But if you try http://127.0.0.1:8000/items/-1 (a negative value): { \"detail\" : [ { \"ctx\" : { \"limit_value\" : 0 }, \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"ensure this value is greater than 0\" , \"type\" : \"value_error.number.not_gt\" } ] }","title":"Type conversions"},{"location":"tutorial/path_params/#openapi-documentation","text":"If you run one of the examples above and navigate to http://127.0.0.1:8000/docs you'll see the OpenAPI documentation. It should look something like:","title":"OpenAPI documentation"},{"location":"tutorial/path_params/#deserialziation-and-parsing","text":"Xpresso offers full support for the the OpenAPI parameter serialization spec . You can control the serialization style using the style and explode arguments to Path() : The Python type can be a scalar value, a collection (like a list or dict) or even a Pydantic model (for object-valued parameters). from typing import List from xpresso import App , Path , PathParam from xpresso.typing import Annotated async def read_items ( items : Annotated [ List [ int ], PathParam ( explode = True , style = \"matrix\" )] ) -> List [ int ]: return items app = App ( routes = [ Path ( path = \"/items/ {items} \" , get = read_items , ), ] ) Navigating to http://127.0.0.1:8000/items/;items=1;items=2;items=3 will return the following JSON: [ 1 , 2 , 3 ]","title":"Deserialziation and parsing"},{"location":"tutorial/query_params/","text":"Query parameters Query parameters are the named parameters that come after the ? in a URL: http://example.com/some/paths/?skip=1&limit=2 This URL has two simple query parameters: skip : value of 1 limit : value of 2 In Xpresso, these are extracted using FromQuery[...] , which is an alias for Annoated[..., QueryParam()] . Since they are part of the URL, they are always received as strings. But just like with path parameters, Xpresso can extract them and parse them into Python types and data structrues: from xpresso import App , FromQuery , Path fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_items ( skip : FromQuery [ int ] = 0 , limit : FromQuery [ int ] = 2 ): return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_items , ), ] ) Now navigate to http://127.0.0.1:8000/items/?skip=1&limit=1 to see the query parameters being used to filter items. You should get the following response: [ { \"item_name\" : \"Bar\" } ] Default (optional) parameters Unlike path parameters which are always required, query paramters can be optional. To make a query parameter optional, simply give the parameter a default value like we do for limit and skip . So, for our example above http://localhost:8000/items/?skip=0&limit=2 and http://localhost:8000/items/ will produce the same result: [ { \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" } ] Of course if you don't give the parameter a default value, it will be required and an error response will automatically be returned if it is missing. For example, given: from typing import Dict from xpresso import App , FromQuery , Path async def double ( input : FromQuery [ int ]) -> Dict [ str , int ]: return { \"result\" : input * 2 } app = App ( routes = [ Path ( path = \"/math/double\" , get = double , ), ] ) If you navigate to http://localhost:8000/math/double/ you will get: { \"detail\" : [ { \"loc\" : [ \"query\" , \"input\" ], \"msg\" : \"Missing required query parameter\" , \"type\" : \"value_error\" } ] } Nullable parameters Just because a parameter has a default value does not mean that it is nullable . For example, http://localhost:8000/items/?limit= means that limit has a value of \"\", which is considered a null value by OpenAPI. If you actually want to accept null values, you can make None an acceptable value for your parameter either using Optional[...] or Union[..., None] . On Python 3.10 you can also do int | None . Now if a null value is sent, it will be converted to None . It is even possible to have a nullable parameter with a non-null default value, for example to express \"the default limit is 10, but you can request all items (no/null limit)\": from typing import Optional from xpresso import App , FromQuery , Path fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_item ( skip : FromQuery [ int ] = 0 , limit : FromQuery [ Optional [ int ]] = 2 ): if limit is None : limit = len ( fake_items_db ) return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_item , ), ] ) If you navigate to http://localhost:8000/items/?limit= you will get 3 items back: [ { \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" } ] While not including the parameter ( http://localhost:8000/items/ ) at all will give you the default (2): [ { \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" } ]","title":"Query Parameters"},{"location":"tutorial/query_params/#query-parameters","text":"Query parameters are the named parameters that come after the ? in a URL: http://example.com/some/paths/?skip=1&limit=2 This URL has two simple query parameters: skip : value of 1 limit : value of 2 In Xpresso, these are extracted using FromQuery[...] , which is an alias for Annoated[..., QueryParam()] . Since they are part of the URL, they are always received as strings. But just like with path parameters, Xpresso can extract them and parse them into Python types and data structrues: from xpresso import App , FromQuery , Path fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_items ( skip : FromQuery [ int ] = 0 , limit : FromQuery [ int ] = 2 ): return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_items , ), ] ) Now navigate to http://127.0.0.1:8000/items/?skip=1&limit=1 to see the query parameters being used to filter items. You should get the following response: [ { \"item_name\" : \"Bar\" } ]","title":"Query parameters"},{"location":"tutorial/query_params/#default-optional-parameters","text":"Unlike path parameters which are always required, query paramters can be optional. To make a query parameter optional, simply give the parameter a default value like we do for limit and skip . So, for our example above http://localhost:8000/items/?skip=0&limit=2 and http://localhost:8000/items/ will produce the same result: [ { \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" } ] Of course if you don't give the parameter a default value, it will be required and an error response will automatically be returned if it is missing. For example, given: from typing import Dict from xpresso import App , FromQuery , Path async def double ( input : FromQuery [ int ]) -> Dict [ str , int ]: return { \"result\" : input * 2 } app = App ( routes = [ Path ( path = \"/math/double\" , get = double , ), ] ) If you navigate to http://localhost:8000/math/double/ you will get: { \"detail\" : [ { \"loc\" : [ \"query\" , \"input\" ], \"msg\" : \"Missing required query parameter\" , \"type\" : \"value_error\" } ] }","title":"Default (optional) parameters"},{"location":"tutorial/query_params/#nullable-parameters","text":"Just because a parameter has a default value does not mean that it is nullable . For example, http://localhost:8000/items/?limit= means that limit has a value of \"\", which is considered a null value by OpenAPI. If you actually want to accept null values, you can make None an acceptable value for your parameter either using Optional[...] or Union[..., None] . On Python 3.10 you can also do int | None . Now if a null value is sent, it will be converted to None . It is even possible to have a nullable parameter with a non-null default value, for example to express \"the default limit is 10, but you can request all items (no/null limit)\": from typing import Optional from xpresso import App , FromQuery , Path fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] async def read_item ( skip : FromQuery [ int ] = 0 , limit : FromQuery [ Optional [ int ]] = 2 ): if limit is None : limit = len ( fake_items_db ) return fake_items_db [ skip : skip + limit ] app = App ( routes = [ Path ( path = \"/items/\" , get = read_item , ), ] ) If you navigate to http://localhost:8000/items/?limit= you will get 3 items back: [ { \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" } ] While not including the parameter ( http://localhost:8000/items/ ) at all will give you the default (2): [ { \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" } ]","title":"Nullable parameters"}]}